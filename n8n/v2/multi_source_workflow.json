{
  "name": "Multi-Source Social Media Scraper",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "multi-source-scrape",
        "options": {}
      },
      "id": "webhook-1",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        240,
        300
      ],
      "webhookId": "multi-source-scrape"
    },
    {
      "parameters": {
        "jsCode": "// Parse the incoming webhook data\nconst inputData = $input.first().json;\nconst sources = inputData.sources || [];\nconst daysSince = inputData.daysSince || 14;\nconst maxResults = inputData.maxResults || 50;\nconst enableExtraction = inputData.enable_extraction !== false;\nconst extractionPrompt = inputData.extraction_prompt || \"Extract location information, business mentions, contact details, and other relevant data from social media posts. Adapt to the specific platform and content type.\";\n\n// Group sources by platform\nconst sourcesByPlatform = {\n  instagram: [],\n  tiktok: [],\n  youtube: []\n};\n\nsources.forEach(source => {\n  if (sourcesByPlatform[source.platform]) {\n    sourcesByPlatform[source.platform].push(source);\n  }\n});\n\n// Prepare output for each platform\nconst output = {\n  sourcesByPlatform,\n  globalSettings: {\n    daysSince,\n    maxResults,\n    enableExtraction,\n    extractionPrompt\n  },\n  originalInput: inputData\n};\n\nreturn [{ json: output }];"
      },
      "id": "parse-input-1",
      "name": "Parse Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "instagram-condition",
              "leftValue": "={{ $json.sourcesByPlatform.instagram.length > 0 }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-instagram-1",
      "name": "Has Instagram Sources?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        680,
        200
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "tiktok-condition",
              "leftValue": "={{ $json.sourcesByPlatform.tiktok.length > 0 }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-tiktok-1",
      "name": "Has TikTok Sources?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        680,
        400
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "youtube-condition",
              "leftValue": "={{ $json.sourcesByPlatform.youtube.length > 0 }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-youtube-1",
      "name": "Has YouTube Sources?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        680,
        600
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare Instagram scraper configuration\nconst sources = $json.sourcesByPlatform.instagram;\nconst globalSettings = $json.globalSettings;\n\n// Collect all direct URLs\nconst directUrls = [];\nconst searchConfigs = [];\n\nsources.forEach(source => {\n  if (source.directUrls && source.directUrls.length > 0) {\n    directUrls.push(...source.directUrls);\n  }\n  \n  if (source.search) {\n    searchConfigs.push({\n      search: source.search,\n      searchType: source.searchType || 'hashtag',\n      searchLimit: source.searchLimit || 10\n    });\n  }\n});\n\n// Build Instagram scraper inputs\nconst instagramInputs = [];\n\n// Add direct URLs configuration\nif (directUrls.length > 0) {\n  instagramInputs.push({\n    directUrls: directUrls,\n    resultsType: 'posts',\n    resultsLimit: globalSettings.maxResults,\n    onlyPostsNewerThan: `${globalSettings.daysSince} days`,\n    addParentData: true\n  });\n}\n\n// Add search configurations\nsearchConfigs.forEach(config => {\n  instagramInputs.push({\n    search: config.search,\n    searchType: config.searchType,\n    searchLimit: config.searchLimit,\n    resultsType: 'posts',\n    resultsLimit: globalSettings.maxResults,\n    onlyPostsNewerThan: `${globalSettings.daysSince} days`,\n    addParentData: true\n  });\n});\n\nreturn instagramInputs.map(input => ({ json: input }));"
      },
      "id": "prepare-instagram-1",
      "name": "Prepare Instagram Config",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        120
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare TikTok scraper configuration\nconst sources = $json.sourcesByPlatform.tiktok;\nconst globalSettings = $json.globalSettings;\n\n// Collect profiles, hashtags, and search queries\nconst profiles = [];\nconst hashtags = [];\nconst searchQueries = [];\n\nsources.forEach(source => {\n  if (source.profiles && source.profiles.length > 0) {\n    profiles.push(...source.profiles);\n  }\n  \n  if (source.hashtags && source.hashtags.length > 0) {\n    hashtags.push(...source.hashtags);\n  }\n  \n  if (source.searchQueries && source.searchQueries.length > 0) {\n    searchQueries.push(...source.searchQueries);\n  }\n});\n\n// Build TikTok scraper input\nconst tiktokInput = {\n  profiles: profiles,\n  hashtags: hashtags,\n  searchQueries: searchQueries,\n  resultsPerPage: globalSettings.maxResults,\n  profileScrapeSections: ['videos'],\n  profileSorting: 'latest',\n  oldestPostDateUnified: `${globalSettings.daysSince} days`,\n  excludePinnedPosts: true,\n  shouldDownloadVideos: false,\n  shouldDownloadCovers: false,\n  shouldDownloadSubtitles: false\n};\n\nreturn [{ json: tiktokInput }];"
      },
      "id": "prepare-tiktok-1",
      "name": "Prepare TikTok Config",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        320
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare YouTube scraper configuration\nconst sources = $json.sourcesByPlatform.youtube;\nconst globalSettings = $json.globalSettings;\n\n// Collect search queries and direct URLs\nconst searchQueries = [];\nconst startUrls = [];\n\nsources.forEach(source => {\n  if (source.searchQueries && source.searchQueries.length > 0) {\n    searchQueries.push(...source.searchQueries);\n  }\n  \n  if (source.startUrls && source.startUrls.length > 0) {\n    source.startUrls.forEach(url => {\n      startUrls.push({ url });\n    });\n  }\n});\n\n// Build YouTube scraper input\nconst youtubeInput = {\n  searchQueries: searchQueries,\n  startUrls: startUrls,\n  maxResults: globalSettings.maxResults,\n  maxResultsShorts: Math.floor(globalSettings.maxResults * 0.3), // 30% shorts\n  maxResultStreams: Math.floor(globalSettings.maxResults * 0.1), // 10% streams\n  downloadSubtitles: false,\n  sortingOrder: 'date',\n  dateFilter: '',\n  videoType: 'video'\n};\n\nreturn [{ json: youtubeInput }];"
      },
      "id": "prepare-youtube-1",
      "name": "Prepare YouTube Config",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        520
      ]
    },
    {
      "parameters": {
        "resource": "actor",
        "operation": "run",
        "actorId": "apify/instagram-scraper",
        "runInput": "={{ $json }}",
        "options": {}
      },
      "id": "instagram-scraper-1",
      "name": "Instagram Scraper",
      "type": "@n8n/n8n-nodes-apify.apify",
      "typeVersion": 1,
      "position": [
        1120,
        120
      ]
    },
    {
      "parameters": {
        "resource": "actor",
        "operation": "run",
        "actorId": "apify/tiktok-scraper",
        "runInput": "={{ $json }}",
        "options": {}
      },
      "id": "tiktok-scraper-1",
      "name": "TikTok Scraper",
      "type": "@n8n/n8n-nodes-apify.apify",
      "typeVersion": 1,
      "position": [
        1120,
        320
      ]
    },
    {
      "parameters": {
        "resource": "actor",
        "operation": "run",
        "actorId": "apify/youtube-scraper",
        "runInput": "={{ $json }}",
        "options": {}
      },
      "id": "youtube-scraper-1",
      "name": "YouTube Scraper",
      "type": "@n8n/n8n-nodes-apify.apify",
      "typeVersion": 1,
      "position": [
        1120,
        520
      ]
    },
    {
      "parameters": {
        "jsCode": "// Combine all scraped data by platform\nconst allData = [];\nconst inputData = $input.all();\n\ninputData.forEach(item => {\n  const data = item.json;\n  const platform = item.node.name.toLowerCase().replace(' scraper', '');\n  \n  if (data && data.data) {\n    data.data.forEach(scrapedItem => {\n      allData.push({\n        platform: platform,\n        data: scrapedItem,\n        scrapedAt: new Date().toISOString()\n      });\n    });\n  }\n});\n\nreturn [{ json: { scrapedData: allData, totalItems: allData.length } }];"
      },
      "id": "combine-scraped-1",
      "name": "Combine Scraped Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1340,
        320
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "extraction-condition",
              "leftValue": "={{ $json.globalSettings.enableExtraction }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-extraction-1",
      "name": "Enable Extraction?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1560,
        320
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare data for LLM extraction\nconst scrapedData = $json.scrapedData || [];\nconst globalSettings = $json.globalSettings || {};\n\n// Group data by platform for better extraction\nconst dataByPlatform = {};\nscrapedData.forEach(item => {\n  if (!dataByPlatform[item.platform]) {\n    dataByPlatform[item.platform] = [];\n  }\n  dataByPlatform[item.platform].push(item.data);\n});\n\n// Create enhanced extraction prompt\nconst platforms = Object.keys(dataByPlatform);\nconst sampleData = {};\n\n// Get sample data for each platform\nplatforms.forEach(platform => {\n  const items = dataByPlatform[platform];\n  if (items && items.length > 0) {\n    sampleData[platform] = items.slice(0, 3); // First 3 items as sample\n  }\n});\n\n// Build enhanced prompt\nconst enhancedPrompt = `${globalSettings.extractionPrompt}\n\nPLATFORM-SPECIFIC INSTRUCTIONS:\n${platforms.map(platform => {\n  const platformInstructions = {\n    instagram: 'For Instagram: Look for caption, likes, comments, location tags, business mentions, contact info in bio or posts.',\n    tiktok: 'For TikTok: Look for text content, engagement metrics, creator info, business mentions, contact details.',\n    youtube: 'For YouTube: Look for video description, channel info, business mentions, contact information, location data.'\n  };\n  return `${platform.toUpperCase()}: ${platformInstructions[platform]}`;\n}).join('\\n')}\n\nDATA STRUCTURE GUIDELINES:\n- Extract structured data that can be organized in tables\n- Use consistent field names across platforms (caption, author, likes, comments, etc.)\n- Handle missing data gracefully\n- Preserve original data types\n- Extract location information, business mentions, and contact details\n\nOUTPUT FORMAT:\nReturn extracted data as JSON array of objects with consistent field names across platforms.`;\n\n// Prepare extraction input\nconst extractionInput = {\n  scrapedData: dataByPlatform,\n  platforms: platforms,\n  sampleData: sampleData,\n  extractionPrompt: enhancedPrompt,\n  metadata: {\n    totalItems: scrapedData.length,\n    platforms: platforms,\n    extractionPrompt: globalSettings.extractionPrompt\n  }\n};\n\nreturn [{ json: extractionInput }];"
      },
      "id": "prepare-extraction-1",
      "name": "Prepare Extraction",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1780,
        200
      ]
    },
    {
      "parameters": {
        "model": "gpt-4",
        "options": {
          "temperature": 0.1,
          "maxTokens": 4000
        },
        "prompt": "={{ $json.extractionPrompt }}",
        "input": "={{ JSON.stringify($json.scrapedData, null, 2) }}",
        "options": {}
      },
      "id": "llm-extraction-1",
      "name": "LLM Extraction",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        2000,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse LLM response and prepare final output\nconst llmResponse = $json.text || '';\nconst extractionInput = $('Prepare Extraction').first().json;\nconst scrapedData = extractionInput.scrapedData;\n\nlet extractedEntities = [];\nlet extractionError = null;\n\ntry {\n  // Try to parse LLM response as JSON\n  const parsedResponse = JSON.parse(llmResponse);\n  \n  if (Array.isArray(parsedResponse)) {\n    extractedEntities = parsedResponse;\n  } else if (parsedResponse.entities && Array.isArray(parsedResponse.entities)) {\n    extractedEntities = parsedResponse.entities;\n  } else {\n    extractionError = 'Invalid LLM response format';\n  }\n} catch (error) {\n  extractionError = `Failed to parse LLM response: ${error.message}`;\n  console.error('LLM Extraction Error:', error);\n}\n\n// Prepare final output\nconst finalOutput = {\n  scraped: scrapedData,\n  extracted: extractedEntities,\n  metadata: {\n    totalScrapedItems: Object.values(scrapedData).reduce((sum, items) => sum + items.length, 0),\n    totalExtractedEntities: extractedEntities.length,\n    platforms: extractionInput.platforms,\n    extractionPrompt: extractionInput.extractionPrompt,\n    extractionError: extractionError,\n    processedAt: new Date().toISOString()\n  }\n};\n\nreturn [{ json: finalOutput }];"
      },
      "id": "prepare-final-output-1",
      "name": "Prepare Final Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2220,
        200
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "webhook-response-1",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.webhookResponse",
      "typeVersion": 1,
      "position": [
        2440,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "// Handle case where extraction is disabled - just return scraped data\nconst scrapedData = $json.scrapedData || [];\nconst globalSettings = $json.globalSettings || {};\n\n// Group data by platform\nconst dataByPlatform = {};\nscrapedData.forEach(item => {\n  if (!dataByPlatform[item.platform]) {\n    dataByPlatform[item.platform] = [];\n  }\n  dataByPlatform[item.platform].push(item.data);\n});\n\nconst finalOutput = {\n  scraped: dataByPlatform,\n  extracted: [], // No extraction when disabled\n  metadata: {\n    totalScrapedItems: scrapedData.length,\n    totalExtractedEntities: 0,\n    platforms: Object.keys(dataByPlatform),\n    extractionEnabled: false,\n    processedAt: new Date().toISOString()\n  }\n};\n\nreturn [{ json: finalOutput }];"
      },
      "id": "no-extraction-1",
      "name": "No Extraction",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1780,
        440
      ]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Parse Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Input": {
      "main": [
        [
          {
            "node": "Has Instagram Sources?",
            "type": "main",
            "index": 0
          },
          {
            "node": "Has TikTok Sources?",
            "type": "main",
            "index": 0
          },
          {
            "node": "Has YouTube Sources?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Instagram Sources?": {
      "main": [
        [
          {
            "node": "Prepare Instagram Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has TikTok Sources?": {
      "main": [
        [
          {
            "node": "Prepare TikTok Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has YouTube Sources?": {
      "main": [
        [
          {
            "node": "Prepare YouTube Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Instagram Config": {
      "main": [
        [
          {
            "node": "Instagram Scraper",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare TikTok Config": {
      "main": [
        [
          {
            "node": "TikTok Scraper",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare YouTube Config": {
      "main": [
        [
          {
            "node": "YouTube Scraper",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Instagram Scraper": {
      "main": [
        [
          {
            "node": "Combine Scraped Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TikTok Scraper": {
      "main": [
        [
          {
            "node": "Combine Scraped Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "YouTube Scraper": {
      "main": [
        [
          {
            "node": "Combine Scraped Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Scraped Data": {
      "main": [
        [
          {
            "node": "Enable Extraction?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enable Extraction?": {
      "main": [
        [
          {
            "node": "Prepare Extraction",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Extraction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Extraction": {
      "main": [
        [
          {
            "node": "LLM Extraction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Extraction": {
      "main": [
        [
          {
            "node": "Prepare Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Final Output": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Extraction": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-11-04T10:00:00.000Z",
      "updatedAt": "2025-11-04T10:00:00.000Z",
      "id": "multi-source"
    }
  ],
  "triggerCount": 0,
  "updatedAt": "2025-11-04T10:00:00.000Z",
  "versionId": "1"
}