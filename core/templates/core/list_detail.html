{% extends "base.html" %}

{% block title %}{{ list.name }} - Vibe Scraper SaaS{% endblock %}

{% block footer %}{% endblock %}

{% block content %}
<!-- CSRF protection enabled -->

<div class="w-full max-w-screen-2xl mx-auto px-4 py-8">
    <div class="mb-8">
        <div class="flex justify-between items-start">
            <div>
                <h1 class="text-3xl font-bold text-gray-900 mb-2">{{ list.name }}</h1>
                {% if list.description %}
                <p class="text-gray-600">{{ list.description }}</p>
                {% endif %}
                <p class="text-sm text-gray-500 mt-2">{{ rows|length }} items</p>
            </div>
            <div class="flex space-x-4">
                <a href="{% url 'list_list' %}"
                   class="inline-flex items-center px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white font-semibold rounded-lg transition-colors duration-200">
                    ‚Üê Back to Lists
                </a>
                <button onclick="showDeleteListModal()"
                        class="inline-flex items-center px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg transition-colors duration-200">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                    </svg>
                    Delete List
                </button>
            </div>
        </div>
    </div>

     <div id="table-editor">
         {% include "snippets/_table_editor.html" %}
     </div>
      </div>

<!-- Inline Edit Modal -->
<div id="edit-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden z-50">
    <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
        <div class="mt-3">
            <h3 class="text-lg font-medium text-gray-900 mb-4" id="edit-modal-title">Edit Cell</h3>
            <div id="edit-modal-content">
                <!-- Dynamic content will be inserted here -->
            </div>
            <div class="flex justify-end space-x-3 mt-4">
                <button onclick="closeEditModal()" class="px-4 py-2 bg-gray-300 text-gray-800 rounded hover:bg-gray-400">Cancel</button>
                <button onclick="saveCellEdit()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Save</button>
            </div>
        </div>
    </div>
</div>

<!-- Delete List Modal -->
<div id="delete-list-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden z-50">
    <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
        <div class="mt-3">
            <h3 class="text-lg font-medium text-red-600 mb-4">Delete List</h3>
            <div class="mb-4">
                <p class="text-sm text-gray-600 mb-2">This action cannot be undone. All data in this list will be permanently deleted.</p>
                <p class="text-sm text-gray-600 mb-4">Type <strong>"{{ list.name }}"</strong> to confirm:</p>
                <input type="text" id="delete-confirmation-input"
                       class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-red-500 focus:border-red-500"
                       placeholder="Type the list name here">
            </div>
            <div class="flex justify-end space-x-3">
                <button onclick="hideDeleteListModal()" class="px-4 py-2 bg-gray-300 text-gray-800 rounded hover:bg-gray-400">Cancel</button>
                <button onclick="confirmDeleteList()" class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700">Delete List</button>
            </div>
        </div>
    </div>
</div>

<!-- Add Column Modal -->
<div id="add-column-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden z-50">
    <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
        <div class="mt-3">
            <h3 class="text-lg font-medium text-gray-900 mb-4">Add New Column</h3>
            <div class="mb-4">
                <label for="column-name" class="block text-sm font-medium text-gray-700 mb-2">Column Name</label>
                <input type="text" id="column-name"
                       class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 mb-4"
                       placeholder="Enter column name">
                <label for="column-type" class="block text-sm font-medium text-gray-700 mb-2">Column Type</label>
                <select id="column-type" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                    <option value="text">Text</option>
                    <option value="number">Number</option>
                    <option value="boolean">Checkbox</option>
                    <option value="date">Date</option>
                    <option value="url">URL</option>
                    <option value="select">Select</option>
                    <option value="multi_select">Multi-Select</option>
                </select>
            </div>
            <div class="flex justify-end space-x-3">
                <button onclick="hideAddColumnModal()" class="px-4 py-2 bg-gray-300 text-gray-800 rounded hover:bg-gray-400">Cancel</button>
                <button onclick="confirmAddColumn()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Add Column</button>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_css %}

{% endblock %}

{% block extra_js %}
<script>
// CSRF token setup for AJAX requests
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

const csrftoken = getCookie('csrftoken');

// Global data for table editor
console.log('columns_json raw:', '{{ columns_json|safe }}');
console.log('rows_json raw:', '{{ rows_json|safe }}');
window.tableEditorData = {
    columns: {{ columns_json|safe }},
    rows: {{ rows_json|safe }}
};
console.log('tableEditorData:', window.tableEditorData);

// Table Editor Alpine.js component
function tableEditor() {
    return {
        // Data
        columns: window.tableEditorData.columns,
        rows: window.tableEditorData.rows,
        filteredRows: [...window.tableEditorData.rows],

        // State
        globalSearch: '',
        columnFilters: {},
        selectedRows: new Set(),
        selectAll: false,
        isIndeterminate: false,
        // Column resizing
        isResizing: false,
        resizingColumnId: null,
        resizingTh: null,
        startX: 0,
        startWidth: 0,
        // Auto-save and undo
        changeHistory: [],
        currentHistoryIndex: -1,
        autoSaveTimeout: null,

        // Computed



        // Methods
        renderCellValue(row, column) {
            const value = this.getCellValue(row, column);
            return this.formatCellValue(value, column);
        },

        getCellValue(row, column) {
            return row.data[column.name] || '';
        },

        formatCellValue(value, column) {
            if (!value) return '<span class="text-gray-400 italic">Empty</span>';

            switch (column.type) {
                case 'boolean':
                    return `<input type="checkbox" ${value ? 'checked' : ''} disabled class="rounded border-gray-300 text-blue-600">`;
                case 'select':
                    return `<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">${value}</span>`;
                case 'url':
                    return `<a href="${value}" target="_blank" class="text-blue-600 hover:text-blue-800 underline">${value.length > 30 ? value.substring(0, 30) + '...' : value}</a>`;
                default:
                    return value;
            }
        },

        renderInlineEditor(row, column) {
            const currentValue = this.getCellValue(row, column);

            switch (column.type) {
                case 'text':
                    return `<textarea
                        x-model="tempValue"
                        x-init="tempValue = '${currentValue.replace(/'/g, "\\'")}'"
                        @keydown.enter.stop="saveInlineEdit($el, ${row.id}, ${column.id})"
                        @keydown.escape.stop="cancelInlineEdit($el)"
                        class="w-full px-2 py-1 border border-blue-500 rounded focus:outline-none bg-white"
                        rows="2"
                        placeholder="Enter text..."
                    ></textarea>`;
                case 'number':
                    return `<input
                        type="number"
                        x-model="tempValue"
                        x-init="tempValue = '${currentValue}'"
                        @keydown.enter.stop="saveInlineEdit($el, ${row.id}, ${column.id})"
                        @keydown.escape.stop="cancelInlineEdit($el)"
                        class="w-full px-2 py-1 border border-blue-500 rounded focus:outline-none bg-white"
                        placeholder="Enter number..."
                    >`;
                case 'boolean':
                    return `<div class="flex items-center justify-center">
                        <input
                            type="checkbox"
                            x-model="tempValue"
                            x-init="tempValue = ${currentValue === 'true' || currentValue === true}"
                            @change="saveInlineEdit($el, ${row.id}, ${column.id})"
                            class="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                        >
                    </div>`;
                case 'date':
                    return `<input
                        type="date"
                        x-model="tempValue"
                        x-init="tempValue = '${currentValue}'"
                        @change="saveInlineEdit($el, ${row.id}, ${column.id})"
                        class="w-full px-2 py-1 border border-blue-500 rounded focus:outline-none bg-white"
                    >`;
                case 'select':
                    return `<select
                        x-model="tempValue"
                        x-init="tempValue = '${currentValue}'"
                        @change="saveInlineEdit($el, ${row.id}, ${column.id})"
                        class="w-full px-2 py-1 border border-blue-500 rounded focus:outline-none bg-white"
                    >
                        <option value="">Select...</option>
                        <option value="Option 1">Option 1</option>
                        <option value="Option 2">Option 2</option>
                        <option value="Option 3">Option 3</option>
                    </select>`;
                default:
                    return `<input
                        type="text"
                        x-model="tempValue"
                        x-init="tempValue = '${currentValue.replace(/'/g, "\\'")}'"
                        @keydown.enter.stop="saveInlineEdit($el, ${row.id}, ${column.id})"
                        @keydown.escape.stop="cancelInlineEdit($el)"
                        class="w-full px-2 py-1 border border-blue-500 rounded focus:outline-none bg-white"
                        placeholder="Enter value..."
                    >`;
            }
        },

        saveInlineEdit(element, rowId, columnId) {
            try {
                const tempValue = element.closest('td').querySelector('[x-model="tempValue"]')?.value ||
                                  element.closest('td').querySelector('[x-model="tempValue"]')?.checked;

                // Record the change for undo functionality
                const oldValue = this.getCellValue({id: rowId}, {id: columnId});
                this.recordChange(rowId, columnId, oldValue, tempValue);

                // Auto-save the change
                this.debouncedAutoSave(rowId, columnId, tempValue);

                // Exit edit mode
                element.closest('td')._x_dataStack[0].editing = false;
            } catch (error) {
                console.error('Error saving inline edit:', error);
                // Force exit edit mode
                element.closest('td')._x_dataStack[0].editing = false;
            }
        },

        cancelInlineEdit(element) {
            try {
                // Just exit edit mode without saving
                element.closest('td')._x_dataStack[0].editing = false;
            } catch (error) {
                console.error('Error canceling inline edit:', error);
                // Force exit edit mode
                element.closest('td')._x_dataStack[0].editing = false;
            }
        },

        recordChange(rowId, columnId, oldValue, newValue) {
            // Remove any history after current index (for when user makes new changes after undo)
            this.changeHistory = this.changeHistory.slice(0, this.currentHistoryIndex + 1);

            // Add new change to history
            this.changeHistory.push({
                rowId: rowId,
                columnId: columnId,
                oldValue: oldValue,
                newValue: newValue,
                timestamp: Date.now()
            });

            // Update current history index
            this.currentHistoryIndex = this.changeHistory.length - 1;

            // Limit history to last 50 changes
            if (this.changeHistory.length > 50) {
                this.changeHistory.shift();
                this.currentHistoryIndex--;
            }
        },

        undo() {
            if (this.currentHistoryIndex >= 0) {
                const change = this.changeHistory[this.currentHistoryIndex];

                // Revert the change
                this.debouncedAutoSave(change.rowId, change.columnId, change.oldValue);

                // Move back in history
                this.currentHistoryIndex--;
            }
        },

        debouncedAutoSave(rowId, columnId, value) {
            // Clear existing timeout
            if (this.autoSaveTimeout) {
                clearTimeout(this.autoSaveTimeout);
            }

            // Set new timeout for auto-save (500ms delay)
            this.autoSaveTimeout = setTimeout(() => {
                this.performAutoSave(rowId, columnId, value);
            }, 500);
        },

        performAutoSave(rowId, columnId, value) {
            const listId = {{ list.pk }};

            // Find the column name
            const column = this.columns.find(c => c.id === columnId);
            if (!column) return;

            // Prepare data for the request
            const data = {
                row_id: rowId,
                column: column.name,
                value: value,
                type: column.type
            };

            // Make the request
            fetch(`/lists/${listId}/rows/update/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': csrftoken,
                },
                body: new URLSearchParams(data)
            })
            .then(response => {
                if (!response.ok) {
                    console.error('Auto-save failed:', response.status);
                }
            })
            .catch(error => {
                console.error('Auto-save error:', error);
            });
        },

        // Row Selection Methods
        toggleRowSelection(rowId) {
            if (this.selectedRows.has(rowId)) {
                this.selectedRows.delete(rowId);
            } else {
                this.selectedRows.add(rowId);
            }
            this.updateSelectAllState();
        },

        toggleSelectAll() {
            if (this.selectAll) {
                // Deselect all
                this.selectedRows.clear();
            } else {
                // Select all visible rows
                this.filteredRows.forEach(row => {
                    this.selectedRows.add(row.id);
                });
            }
            this.updateSelectAllState();
        },

        updateSelectAllState() {
            const visibleRowIds = new Set(this.filteredRows.map(row => row.id));
            const selectedVisibleRows = [...this.selectedRows].filter(id => visibleRowIds.has(id));

            if (selectedVisibleRows.length === 0) {
                this.selectAll = false;
                this.isIndeterminate = false;
            } else if (selectedVisibleRows.length === this.filteredRows.length) {
                this.selectAll = true;
                this.isIndeterminate = false;
            } else {
                this.selectAll = false;
                this.isIndeterminate = true;
            }
        },

        clearSelection() {
            this.selectedRows.clear();
            this.selectAll = false;
            this.isIndeterminate = false;
        },

        deleteSelectedRows() {
            const count = this.selectedRows.size;
            if (count === 0) return;

            if (confirm(`Are you sure you want to delete ${count} selected row${count === 1 ? '' : 's'}? This action cannot be undone.`)) {
                // This would typically make an HTMX request to delete multiple rows
                console.log('Delete selected rows:', [...this.selectedRows]);
                this.clearSelection();
                // TODO: Implement actual bulk delete via HTMX
            }
        },

        addRow() {
            // HTMX handles the request, response is handled by the event listener below
        },

        init() {
            // HTMX event listener for add row response
            document.addEventListener('htmx:afterRequest', (event) => {
                if (event.detail.xhr && event.detail.xhr.responseURL &&
                    event.detail.xhr.responseURL.includes('add-blank-row')) {
                    try {
                        const response = JSON.parse(event.detail.xhr.response);
                        if (response.success && response.row) {
                            // Add the new row to the data arrays
                            this.rows.push(response.row);
                            this.filteredRows.push(response.row);
                            this.updateSelectAllState();
                        }
                    } catch (e) {
                        console.error('Error parsing add row response:', e);
                    }
                }
            });
        },

        insertRowBelow(rowId) {
            // Redirect to add row page with insert_after parameter
            const listId = {{ list.pk }};
            window.location.href = `/lists/${listId}/rows/create/?insert_after=${rowId}`;
        },

        deleteRow(rowId) {
            // HTMX handles the deletion now - this function is kept for potential future enhancements
            console.log('Delete row:', rowId);
        },

        addColumn() {
            // Simple prompt for column creation (could be replaced with a modal)
            const columnName = prompt('Enter column name:');
            const columnType = prompt('Enter column type (text, number, boolean, date, url, select):', 'text');

            if (columnName && columnType) {
                // For now, just redirect to refresh the page
                const listId = {{ list.pk }};
                window.location.href = `/lists/${listId}/columns/create/?name=${encodeURIComponent(columnName)}&column_type=${columnType}`;
            }
        },

        editColumn(columnId) {
            // This would typically open a modal or make an HTMX request
            console.log('Edit column:', columnId);
        },

        deleteColumn(columnId) {
            if (confirm('Are you sure you want to delete this column? This action cannot be undone.')) {
                // This would typically make an HTMX request to delete the column
                console.log('Delete column:', columnId);
            }
        },

        insertColumn(columnId, position) {
            // This would typically make an HTMX request to insert a column
            console.log('Insert column:', columnId, position);
        },

        sortByColumn(columnId) {
            if (this.sortedColumn === columnId) {
                this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                this.sortedColumn = columnId;
                this.sortDirection = 'asc';
            }
            this.applySorting();
        },

        applySorting() {
            if (!this.sortedColumn) return;

            const column = this.columns.find(c => c.id === this.sortedColumn);
            if (!column) return;

            this.filteredRows.sort((a, b) => {
                const aVal = this.getCellValue(a, column);
                const bVal = this.getCellValue(b, column);

                let result = 0;
                if (aVal < bVal) result = -1;
                if (aVal > bVal) result = 1;

                return this.sortDirection === 'asc' ? result : -result;
            });
        },

        applyFilters() {
            const filtered = this.rows.filter(row => {
                // Global search
                if (this.globalSearch) {
                    const searchTerm = this.globalSearch.toLowerCase();
                    const rowText = Object.values(row.data).join(' ').toLowerCase();
                    if (!rowText.includes(searchTerm)) return false;
                }

                // Column filters
                for (const [columnId, filterValue] of Object.entries(this.columnFilters)) {
                    if (!filterValue) continue;

                    const column = this.columns.find(c => c.id.toString() === columnId);
                    if (!column) continue;

                    const cellValue = this.getCellValue(row, column);
                    if (!cellValue || !cellValue.toString().toLowerCase().includes(filterValue.toLowerCase())) {
                        return false;
                    }
                }

                return true;
            });

            // Force reactivity by creating a new array reference
            this.filteredRows = [...filtered];

            this.applySorting();
            this.updateSelectAllState(); // Update selection state when filters change
        },

        startColumnResize(event, columnId) {
            this.isResizing = true;
            this.resizingColumnId = columnId;
            this.startX = event.clientX;

            // Get the current width of the column
            const th = event.target.closest('th');
            this.resizingTh = th;
            this.startWidth = th.offsetWidth;

            // Add global mouse event listeners
            document.addEventListener('mousemove', this.handleColumnResize.bind(this));
            document.addEventListener('mouseup', this.stopColumnResize.bind(this));

            // Prevent text selection during resize
            document.body.style.userSelect = 'none';
            document.body.style.cursor = 'col-resize';
        },

        handleColumnResize(event) {
            if (!this.isResizing || !this.resizingTh) return;

            const deltaX = event.clientX - this.startX;
            const newWidth = Math.max(80, this.startWidth + deltaX); // Minimum width of 80px

            // Update the stored TH element width
            this.resizingTh.style.width = newWidth + 'px';
            this.resizingTh.style.minWidth = newWidth + 'px';
        },

        stopColumnResize() {
            if (!this.isResizing) return;

            this.isResizing = false;
            this.resizingColumnId = null;
            this.resizingTh = null;

            // Remove event listeners
            document.removeEventListener('mousemove', this.handleColumnResize.bind(this));
            document.removeEventListener('mouseup', this.stopColumnResize.bind(this));

            // Restore cursor and text selection
            document.body.style.userSelect = '';
            document.body.style.cursor = '';
        },

        init() {
            // HTMX event listener for add row response
            document.addEventListener('htmx:afterRequest', (event) => {
                if (event.detail.xhr && event.detail.xhr.responseURL &&
                    event.detail.xhr.responseURL.includes('add-blank-row')) {
                    try {
                        const response = JSON.parse(event.detail.xhr.response);
                        if (response.success && response.row) {
                            // Add the new row to the data arrays
                            this.rows.push(response.row);
                            this.filteredRows.push(response.row);
                            this.updateSelectAllState();
                        }
                    } catch (e) {
                        console.error('Error parsing add row response:', e);
                    }
                }
            });

            // HTMX event listener for delete row response
            document.addEventListener('htmx:afterRequest', (event) => {
                if (event.detail.xhr && event.detail.xhr.responseURL &&
                    event.detail.xhr.responseURL.includes('delete')) {
                    try {
                        const response = JSON.parse(event.detail.xhr.response);
                        if (response.success) {
                            // Row was deleted successfully, HTMX already removed it from DOM
                            // No additional action needed for data arrays since HTMX handles DOM updates
                        }
                    } catch (e) {
                        // HTMX delete responses might not be JSON, ignore parsing errors
                    }
                }
            });
        }
    }
}

// Global variables
let currentEditCell = null;
let currentEditRowId = null;
let currentEditColumn = null;
let currentEditType = null;



// Cell editing functions
function editCell(rowId, columnName, columnType, cellElement) {
    // Set global variables
    currentEditRowId = rowId;
    currentEditColumn = columnName;
    currentEditType = columnType;

    // Get current value
    let currentValue = '';
    if (columnType === 'boolean') {
        const checkbox = cellElement.querySelector('input[type="checkbox"]');
        currentValue = checkbox ? checkbox.checked : false;
    } else {
        currentValue = cellElement.textContent.trim();
    }

    // Create input HTML based on type
    let inputHtml = '';
    if (columnType === 'boolean') {
        inputHtml = `<input type="checkbox" id="edit-input" ${currentValue ? 'checked' : ''} class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">`;
    } else {
        inputHtml = `<input type="text" id="edit-input" value="${currentValue}" class="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">`;
    }

    // Show modal
    const modal = document.getElementById('edit-modal');
    const content = document.getElementById('edit-modal-content');
    const title = document.getElementById('edit-modal-title');

    title.textContent = `Edit ${columnName}`;
    content.innerHTML = inputHtml;
    modal.classList.remove('hidden');

    // Focus the input
    setTimeout(() => {
        const input = document.getElementById('edit-input');
        if (input) {
            input.focus();
            if (input.type !== 'checkbox') {
                input.select();
            }
        }
    }, 100);
}

// Save cell edit
function saveCellEdit() {
    const input = document.getElementById('edit-input');
    if (!input) return;

    let value;
    if (currentEditType === 'boolean') {
        value = input.checked;
    } else {
        value = input.value;
    }

    // Send AJAX request to update the cell
    const listId = {{ list.pk }};
    fetch(`/lists/${listId}/rows/update/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-CSRFToken': csrftoken,
        },
        body: `row_id=${currentEditRowId}&column=${encodeURIComponent(currentEditColumn)}&value=${encodeURIComponent(value)}&type=${currentEditType}`
    })
    .then(response => {
        if (response.ok) {
            location.reload();
        } else {
            alert('Error updating cell');
        }
    });

    closeEditModal();
}

// Close edit modal
function closeEditModal() {
    document.getElementById('edit-modal').classList.add('hidden');
    currentEditCell = null;
    currentEditRowId = null;
    currentEditColumn = null;
    currentEditType = null;
}

// Add new row
function addNewRow() {
    const listId = {{ list.pk }};
    // Redirect to the row creation page
    window.location.href = `/lists/${listId}/rows/create/`;
}

// Delete row
function deleteRow(rowId) {
    if (!confirm('Are you sure you want to delete this row?')) return;

    const listId = {{ list.pk }};
    fetch(`/lists/${listId}/rows/delete/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-CSRFToken': csrftoken,
        },
        body: `row_id=${rowId}`
    })
    .then(response => {
        if (response.ok) {
            location.reload();
        } else {
            alert('Error deleting row');
        }
    });
}

// CSRF protection enabled

// Column resizing functionality
function setupColumnResizing() {
    const table = document.getElementById('notion-table');
    const ths = table.querySelectorAll('th.resizable');

    ths.forEach(th => {
        th.addEventListener('mousedown', function(e) {
            if (e.offsetX > th.offsetWidth - 10) { // Only resize if clicking on the right edge
                isResizing = true;
                currentResizingTh = th;
                startX = e.pageX;
                startWidth = th.offsetWidth;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            }
        });
    });

    document.addEventListener('mousemove', function(e) {
        if (isResizing && currentResizingTh) {
            const newWidth = startWidth + (e.pageX - startX);
            if (newWidth >= 80 && newWidth <= 400) { // Min 80px, max 400px
                currentResizingTh.style.width = newWidth + 'px';
                // Save to localStorage for persistence
                const columnId = currentResizingTh.dataset.columnId;
                localStorage.setItem(`column-width-${columnId}`, newWidth);
            }
        }
    });

    document.addEventListener('mouseup', function() {
        if (isResizing) {
            isResizing = false;
            currentResizingTh = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        }
    });

    // Load saved widths on page load
    ths.forEach(th => {
        const columnId = th.dataset.columnId;
        const savedWidth = localStorage.getItem(`column-width-${columnId}`);
        if (savedWidth) {
            th.style.width = savedWidth + 'px';
        }
    });
}



// Add column modal functions
function showAddColumnModal() {
    document.getElementById('add-column-modal').classList.remove('hidden');
    document.getElementById('column-name').focus();
}

function hideAddColumnModal() {
    document.getElementById('add-column-modal').classList.add('hidden');
    document.getElementById('column-name').value = '';
    document.getElementById('column-type').selectedIndex = 0;
}

function confirmAddColumn() {
    const name = document.getElementById('column-name').value.trim();
    const type = document.getElementById('column-type').value;

    if (!name) {
        alert('Please enter a column name.');
        document.getElementById('column-name').focus();
        return;
    }

    const listId = {{ list.pk }};
    fetch(`/lists/${listId}/columns/create/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-CSRFToken': csrftoken,
        },
        body: `name=${encodeURIComponent(name)}&column_type=${type}&required=false`
    })
    .then(response => {
        if (response.ok) {
            location.reload();
        } else {
            alert('Error adding column');
        }
    })
    .catch(error => {
        alert('Error adding column');
    });

    hideAddColumnModal();
}

// Delete list modal functions
function showDeleteListModal() {
    document.getElementById('delete-list-modal').classList.remove('hidden');
    document.getElementById('delete-confirmation-input').focus();
}

function hideDeleteListModal() {
    document.getElementById('delete-list-modal').classList.add('hidden');
    document.getElementById('delete-confirmation-input').value = '';
}

function confirmDeleteList() {
    const input = document.getElementById('delete-confirmation-input');
    const confirmation = input.value.trim();
    const listName = '{{ list.name }}';

    if (confirmation !== listName) {
        alert('Please type the exact list name to confirm deletion.');
        input.focus();
        return;
    }

    const listId = {{ list.pk }};
    fetch(`/lists/${listId}/delete/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-CSRFToken': csrftoken,
        },
        body: `confirmation=${encodeURIComponent(confirmation)}`
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = '{% url "list_list" %}';
        } else {
            alert(data.error || 'Error deleting list');
        }
    })
    .catch(error => {
        alert('Error deleting list');
    });
}
</script>
{% endblock %}