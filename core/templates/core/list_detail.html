{% extends "base.html" %}

{% block title %}{{ list.name }} - Vibe Scraper SaaS{% endblock %}

{% block footer %}{% endblock %}

{% block content %}
<!-- CSRF protection enabled -->

<div class="w-full max-w-screen-2xl mx-auto px-4 py-8">
    <div class="mb-8">
        <div class="flex justify-between items-start">
            <div>
                <h1 class="text-3xl font-bold text-gray-900 mb-2">{{ list.name }}</h1>
                {% if list.description %}
                <p class="text-gray-600">{{ list.description }}</p>
                {% endif %}
                <p class="text-sm text-gray-500 mt-2">{{ rows|length }} items</p>
            </div>
            <div class="flex space-x-4">
                <a href="{% url 'list_list' %}"
                   class="inline-flex items-center px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white font-semibold rounded-lg transition-colors duration-200">
                    ‚Üê Back to Lists
                </a>
                <button onclick="showDeleteListModal()"
                        class="inline-flex items-center px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg transition-colors duration-200">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                    </svg>
                    Delete List
                </button>
            </div>
        </div>
    </div>

     <div id="table-editor">
         {% include "snippets/_table_editor.html" %}
     </div>
      </div>

<!-- Inline Edit Modal -->
<div id="edit-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden z-50">
    <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
        <div class="mt-3">
            <h3 class="text-lg font-medium text-gray-900 mb-4" id="edit-modal-title">Edit Cell</h3>
            <div id="edit-modal-content">
                <!-- Dynamic content will be inserted here -->
            </div>
            <div class="flex justify-end space-x-3 mt-4">
                <button onclick="closeEditModal()" class="px-4 py-2 bg-gray-300 text-gray-800 rounded hover:bg-gray-400">Cancel</button>
                <button onclick="saveCellEdit()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Save</button>
            </div>
        </div>
    </div>
</div>

<!-- Delete List Modal -->
<div id="delete-list-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden z-50">
    <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
        <div class="mt-3">
            <h3 class="text-lg font-medium text-red-600 mb-4">Delete List</h3>
            <div class="mb-4">
                <p class="text-sm text-gray-600 mb-2">This action cannot be undone. All data in this list will be permanently deleted.</p>
                <p class="text-sm text-gray-600 mb-4">Type <strong>"{{ list.name }}"</strong> to confirm:</p>
                <input type="text" id="delete-confirmation-input"
                       class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-red-500 focus:border-red-500"
                       placeholder="Type the list name here">
            </div>
            <div class="flex justify-end space-x-3">
                <button onclick="hideDeleteListModal()" class="px-4 py-2 bg-gray-300 text-gray-800 rounded hover:bg-gray-400">Cancel</button>
                <button onclick="confirmDeleteList()" class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700">Delete List</button>
            </div>
        </div>
    </div>
</div>

<!-- Add Column Modal -->
<div id="add-column-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden z-50">
    <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
        <div class="mt-3">
            <h3 class="text-lg font-medium text-gray-900 mb-4">Add New Column</h3>
            <div class="mb-4">
                <label for="column-name" class="block text-sm font-medium text-gray-700 mb-2">Column Name</label>
                <input type="text" id="column-name"
                       class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 mb-4"
                       placeholder="Enter column name">
                <label for="column-type" class="block text-sm font-medium text-gray-700 mb-2">Column Type</label>
                <select id="column-type" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                    <option value="text">Text</option>
                    <option value="number">Number</option>
                    <option value="boolean">Checkbox</option>
                    <option value="date">Date</option>
                    <option value="url">URL</option>
                    <option value="select">Select</option>
                    <option value="multi_select">Multi-Select</option>
                </select>
            </div>
            <div class="flex justify-end space-x-3">
                <button onclick="hideAddColumnModal()" class="px-4 py-2 bg-gray-300 text-gray-800 rounded hover:bg-gray-400">Cancel</button>
                <button onclick="confirmAddColumn()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Add Column</button>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_css %}

{% endblock %}

{% block extra_js %}
<script>
// CSRF token setup for AJAX requests
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

const csrftoken = getCookie('csrftoken');

// Global data for table editor
console.log('columns_json raw:', '{{ columns_json|safe }}');
console.log('rows_json raw:', '{{ rows_json|safe }}');
window.tableEditorData = {
    columns: {{ columns_json|safe }},
    rows: {{ rows_json|safe }}
};
console.log('tableEditorData:', window.tableEditorData);

// Table Editor Alpine.js component
function tableEditor() {
    return {
        // Data
        columns: window.tableEditorData.columns,
        rows: window.tableEditorData.rows,
        filteredRows: [...window.tableEditorData.rows],

        // State
        globalSearch: '',
        columnFilters: {},
        selectedRows: new Set(),
        selectAll: false,
        isIndeterminate: false,
        // Column editing
        editingColumnName: null,
        tempColumnName: '',
        // Column resizing
        isResizing: false,
        resizingColumnId: null,
        resizingTh: null,
        startX: 0,
        startWidth: 0,
        // Auto-save and undo
        changeHistory: [],
        currentHistoryIndex: -1,
        autoSaveTimeout: null,

        // Computed



        // Methods
        renderCellValue(row, column) {
            const value = this.getCellValue(row, column);
            return this.formatCellValue(value, column);
        },

        getCellValue(row, column) {
            if (!row || !row.data || !column || !column.name) {
                return '';
            }
            return row.data[column.name] || '';
        },

        formatCellValue(value, column) {
            if (!value) return '<span class="text-gray-400 italic">Empty</span>';

            switch (column.type) {
                case 'boolean':
                    return `<input type="checkbox" ${value ? 'checked' : ''} disabled class="rounded border-gray-300 text-blue-600">`;
                case 'select':
                    return `<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">${value}</span>`;
                case 'url':
                    return `<a href="${value}" target="_blank" class="text-blue-600 hover:text-blue-800 underline">${value.length > 30 ? value.substring(0, 30) + '...' : value}</a>`;
                default:
                    return value;
            }
        },

        renderInlineEditor(row, column) {
            // Debug logging
            console.log('renderInlineEditor:', { row, column });
            const currentValue = this.getCellValue(row, column) || '';

            switch (column.type) {
                case 'text':
                    return `<textarea
                        x-model="tempValue"
                        x-init="tempValue = '${(currentValue || '').replace(/'/g, "\\'")}'"
                        @keydown.enter.stop="saveInlineEdit($el, ${row.id}, ${column.id})"
                        @keydown.escape.stop="cancelInlineEdit($el)"
                        class="w-full px-2 py-1 border border-blue-500 rounded focus:outline-none bg-white"
                        rows="2"
                        placeholder="Enter text..."
                    ></textarea>`;
                case 'number':
                    return `<input
                        type="number"
                        x-model="tempValue"
                        x-init="tempValue = '${currentValue || ''}'"
                        @keydown.enter.stop="saveInlineEdit($el, ${row.id}, ${column.id})"
                        @keydown.escape.stop="cancelInlineEdit($el)"
                        class="w-full px-2 py-1 border border-blue-500 rounded focus:outline-none bg-white"
                        placeholder="Enter number..."
                    >`;
                case 'boolean':
                    return `<div class="flex items-center justify-center">
                        <input
                            type="checkbox"
                            x-model="tempValue"
                            x-init="tempValue = ${(currentValue === 'true' || currentValue === true)}"
                            @change="saveInlineEdit($el, ${row.id}, ${column.id})"
                            class="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                        >
                    </div>`;
                case 'date':
                    return `<input
                        type="date"
                        x-model="tempValue"
                        x-init="tempValue = '${currentValue || ''}'"
                        @change="saveInlineEdit($el, ${row.id}, ${column.id})"
                        class="w-full px-2 py-1 border border-blue-500 rounded focus:outline-none bg-white"
                    >`;
                case 'select':
                    return `<select
                        x-model="tempValue"
                        x-init="tempValue = '${currentValue || ''}'"
                        @change="saveInlineEdit($el, ${row.id}, ${column.id})"
                        class="w-full px-2 py-1 border border-blue-500 rounded focus:outline-none bg-white"
                    >
                        <option value="">Select...</option>
                        <option value="Option 1">Option 1</option>
                        <option value="Option 2">Option 2</option>
                        <option value="Option 3">Option 3</option>
                    </select>`;
                default:
                    return `<input
                        type="text"
                        x-model="tempValue"
                        x-init="tempValue = '${(currentValue || '').replace(/'/g, "\\'")}'"
                        @keydown.enter.stop="saveInlineEdit($el, ${row.id}, ${column.id})"
                        @keydown.escape.stop="cancelInlineEdit($el)"
                        class="w-full px-2 py-1 border border-blue-500 rounded focus:outline-none bg-white"
                        placeholder="Enter value..."
                    >`;
            }
        },

        saveInlineEdit(element, rowId, columnId) {
            try {
                const tempValue = element.closest('td').querySelector('[x-model="tempValue"]')?.value ||
                                  element.closest('td').querySelector('[x-model="tempValue"]')?.checked;

                // Record the change for undo functionality
                const row = this.rows.find(r => r.id === rowId);
                const column = this.columns.find(c => c.id === columnId);
                
                // Debug logging
                console.log('saveInlineEdit:', { rowId, columnId, row, column, tempValue });
                
                const oldValue = row && column ? this.getCellValue(row, column) : '';
                this.recordChange(rowId, columnId, oldValue, tempValue);

                // Update local data immediately for UI update
                if (row && column && row.data && column.name) {
                    row.data[column.name] = tempValue;
                    this.applyFilters(); // Update filteredRows
                }

                // Auto-save the change
                this.debouncedAutoSave(rowId, columnId, tempValue);

                // Exit edit mode
                element.closest('td')._x_dataStack[0].editing = false;
            } catch (error) {
                console.error('Error saving inline edit:', error);
                // Force exit edit mode
                element.closest('td')._x_dataStack[0].editing = false;
            }
        },

        cancelInlineEdit(element) {
            try {
                // Just exit edit mode without saving
                element.closest('td')._x_dataStack[0].editing = false;
            } catch (error) {
                console.error('Error canceling inline edit:', error);
                // Force exit edit mode
                element.closest('td')._x_dataStack[0].editing = false;
            }
        },

        recordChange(rowId, columnId, oldValue, newValue) {
            // Remove any history after current index (for when user makes new changes after undo)
            this.changeHistory = this.changeHistory.slice(0, this.currentHistoryIndex + 1);

            // Add new change to history
            this.changeHistory.push({
                rowId: rowId,
                columnId: columnId,
                oldValue: oldValue,
                newValue: newValue,
                timestamp: Date.now()
            });

            // Update current history index
            this.currentHistoryIndex = this.changeHistory.length - 1;

            // Limit history to last 50 changes
            if (this.changeHistory.length > 50) {
                this.changeHistory.shift();
                this.currentHistoryIndex--;
            }
        },

        undo() {
            if (this.currentHistoryIndex >= 0) {
                const change = this.changeHistory[this.currentHistoryIndex];

                // Update local data immediately
                const row = this.rows.find(r => r.id === change.rowId);
                const column = this.columns.find(c => c.id === change.columnId);
                if (row && column) {
                    row.data[column.name] = change.oldValue;
                    this.applyFilters(); // Update filteredRows
                }

                // Revert the change on server
                this.debouncedAutoSave(change.rowId, change.columnId, change.oldValue);

                // Move back in history
                this.currentHistoryIndex--;
            }
        },

        debouncedAutoSave(rowId, columnId, value) {
            // Clear existing timeout
            if (this.autoSaveTimeout) {
                clearTimeout(this.autoSaveTimeout);
            }

            // Set new timeout for auto-save (500ms delay)
            this.autoSaveTimeout = setTimeout(() => {
                this.performAutoSave(rowId, columnId, value);
            }, 500);
        },

        performAutoSave(rowId, columnId, value) {
            const listId = {{ list.pk }};

            // Find the column name
            const column = this.columns.find(c => c.id === columnId);
            if (!column) return;

            // Prepare data for the request
            const data = {
                row_id: rowId,
                column: column.name,
                value: value,
                type: column.type
            };

            // Make the request
            fetch(`/lists/${listId}/rows/update/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': csrftoken,
                },
                body: new URLSearchParams(data)
            })
            .then(response => {
                if (!response.ok) {
                    console.error('Auto-save failed:', response.status);
                    // Revert local change on failure
                    this.revertLocalChange(rowId, columnId, value);
                }
            })
            .catch(error => {
                console.error('Auto-save error:', error);
                // Revert local change on error
                this.revertLocalChange(rowId, columnId, value);
            });
        },

        revertLocalChange(rowId, columnId, originalValue) {
            // Find the most recent change for this cell and revert to the previous value
            const recentChange = [...this.changeHistory]
                .reverse()
                .find(change => change.rowId === rowId && change.columnId === columnId);

            if (recentChange) {
                const row = this.rows.find(r => r.id === rowId);
                const column = this.columns.find(c => c.id === columnId);
                if (row && column) {
                    row.data[column.name] = recentChange.oldValue;
                    this.applyFilters();
                }
            }
        },

        // Row Selection Methods
        toggleRowSelection(rowId) {
            if (this.selectedRows.has(rowId)) {
                this.selectedRows.delete(rowId);
            } else {
                this.selectedRows.add(rowId);
            }
            this.updateSelectAllState();
        },

        toggleSelectAll() {
            if (this.selectAll) {
                // Deselect all
                this.selectedRows.clear();
            } else {
                // Select all visible rows
                this.filteredRows.forEach(row => {
                    this.selectedRows.add(row.id);
                });
            }
            this.updateSelectAllState();
        },

        updateSelectAllState() {
            const visibleRowIds = new Set(this.filteredRows.map(row => row.id));
            const selectedVisibleRows = [...this.selectedRows].filter(id => visibleRowIds.has(id));

            if (selectedVisibleRows.length === 0) {
                this.selectAll = false;
                this.isIndeterminate = false;
            } else if (selectedVisibleRows.length === this.filteredRows.length) {
                this.selectAll = true;
                this.isIndeterminate = false;
            } else {
                this.selectAll = false;
                this.isIndeterminate = true;
            }
        },

        clearSelection() {
            this.selectedRows.clear();
            this.selectAll = false;
            this.isIndeterminate = false;
        },

        deleteSelectedRows() {
            const count = this.selectedRows.size;
            if (count === 0) return;

            if (confirm(`Are you sure you want to delete ${count} selected row${count === 1 ? '' : 's'}? This action cannot be undone.`)) {
                const selectedIds = [...this.selectedRows];
                const listId = {{ list.pk }};
                let completed = 0;
                const total = selectedIds.length;

                // Delete each row individually
                selectedIds.forEach(rowId => {
                    fetch(`/lists/${listId}/rows/delete/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'X-CSRFToken': csrftoken,
                        },
                        body: `row_id=${rowId}`
                    })
                    .then(response => {
                        completed++;
                        if (response.ok) {
                            // Remove from local data
                            this.rows = this.rows.filter(row => row.id !== rowId);
                        } else {
                            console.error(`Failed to delete row ${rowId}`);
                        }

                        // Update UI when all requests complete
                        if (completed === total) {
                            this.applyFilters();
                            this.clearSelection();
                        }
                    })
                    .catch(error => {
                        completed++;
                        console.error(`Error deleting row ${rowId}:`, error);

                        // Update UI when all requests complete
                        if (completed === total) {
                            this.applyFilters();
                            this.clearSelection();
                        }
                    });
                });
            }
        },

addRow() {
            const listId = {{ list.pk }};
            
            fetch(`/lists/${listId}/rows/add-blank/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': csrftoken,
                }
            })
            .then(response => response.json())
            .then(data => {
                console.log('Add row response:', data);
                if (data.success && data.row) {
                    // Add the new row to the data arrays
                    this.rows.push(data.row);
                    this.applyFilters(); // This will update filteredRows properly
                    this.updateSelectAllState();
                    console.log('Row added. New rows count:', this.rows.length);
                } else {
                    alert('Error adding row');
                }
            })
            .catch(error => {
                console.error('Error adding row:', error);
                alert('Error adding row');
            });
        },

        insertRowBelow(rowId) {
            // Redirect to add row page with insert_after parameter
            const listId = {{ list.pk }};
            window.location.href = `/lists/${listId}/rows/create/?insert_after=${rowId}`;
        },



addNewColumn() {
            const listId = {{ list.pk }};
            
            // Generate a unique column name
            let columnNumber = this.columns.length + 1;
            let defaultName = `Column ${columnNumber}`;
            
            // Check if name already exists and find next available number
            while (this.columns.some(col => col.name === defaultName)) {
                columnNumber++;
                defaultName = `Column ${columnNumber}`;
            }
            
            const defaultType = 'text';

fetch(`/lists/${listId}/columns/create/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': csrftoken,
                },
                body: `name=${encodeURIComponent(defaultName)}&column_type=${defaultType}&required=false`
            })
            .then(response => response.json())
            .then(data => {
                console.log('Add column response:', data);
                if (data.success && data.column) {
                    // Add new column to data arrays
                    this.columns.push(data.column);
                    this.applyFilters(); // This will update filteredRows properly
                    console.log('Column added. New columns count:', this.columns.length);
                } else {
                    alert('Error adding column');
                }
            })
            .catch(error => {
                console.error('Add column error:', error);
                alert('Error adding column');
            });
        },

        startEditColumnName(columnId) {
            this.editingColumnName = columnId;
        },

        cancelEditColumnName() {
            this.editingColumnName = null;
        },

        saveColumnName(columnId, newName) {
            if (!newName.trim()) return;
            
            const listId = {{ list.pk }};
            fetch(`/lists/${listId}/columns/${columnId}/update/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': csrftoken,
                },
                body: `name=${encodeURIComponent(newName.trim())}`
            })
            .then(response => {
                if (response.ok) {
                    // Update local data
                    const column = this.columns.find(c => c.id === columnId);
                    if (column) {
                        column.name = newName.trim();
                    }
                    this.editingColumnName = null;
                } else {
                    alert('Error updating column name');
                }
            })
            .catch(error => {
                console.error('Update column error:', error);
                alert('Error updating column name');
            });
        },

        editColumn(columnId) {
            // For now, just focus on the column name for inline editing
            this.startEditColumnName(columnId);
        },

        deleteColumn(columnId) {
            if (confirm('Are you sure you want to delete this column? This action cannot be undone.')) {
                const listId = {{ list.pk }};
                fetch(`/lists/${listId}/columns/${columnId}/delete/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': csrftoken,
                    }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Remove column from local data and reload page
                        location.reload();
                    } else {
                        alert(data.error || 'Error deleting column');
                    }
                })
                .catch(error => {
                    console.error('Delete column error:', error);
                    alert('Error deleting column');
                });
            }
        },

        insertColumn(columnId, position) {
            const listId = {{ list.pk }};
            const column = this.columns.find(c => c.id === columnId);
            const currentIndex = this.columns.findIndex(c => c.id === columnId);
            
            let newName = `Column ${this.columns.length + 1}`;
            let newOrder;
            
            if (position === 'left') {
                newOrder = currentIndex;
            } else {
                newOrder = currentIndex + 1;
            }
            
            // Create new column with specific order
            fetch(`/lists/${listId}/columns/create/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': csrftoken,
                },
                body: `name=${encodeURIComponent(newName)}&column_type=text&required=false&order=${newOrder}`
            })
            .then(response => {
                if (response.ok) {
                    // Reload page to show new column in correct position
                    location.reload();
                } else {
                    alert('Error inserting column');
                }
            })
            .catch(error => {
                console.error('Insert column error:', error);
                alert('Error inserting column');
            });
        },

        sortByColumn(columnId) {
            if (this.sortedColumn === columnId) {
                this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                this.sortedColumn = columnId;
                this.sortDirection = 'asc';
            }
            this.applySorting();
        },

        applySorting() {
            if (!this.sortedColumn) return;

            const column = this.columns.find(c => c.id === this.sortedColumn);
            if (!column) return;

            this.filteredRows.sort((a, b) => {
                const aVal = this.getCellValue(a, column);
                const bVal = this.getCellValue(b, column);

                let result = 0;
                if (aVal < bVal) result = -1;
                if (aVal > bVal) result = 1;

                return this.sortDirection === 'asc' ? result : -result;
            });
        },

        applyFilters() {
            const filtered = this.rows.filter(row => {
                // Global search
                if (this.globalSearch) {
                    const searchTerm = this.globalSearch.toLowerCase();
                    const rowText = Object.values(row.data).join(' ').toLowerCase();
                    if (!rowText.includes(searchTerm)) return false;
                }

                // Column filters
                for (const [columnId, filterValue] of Object.entries(this.columnFilters)) {
                    if (!filterValue) continue;

                    const column = this.columns.find(c => c.id.toString() === columnId);
                    if (!column) continue;

                    const cellValue = this.getCellValue(row, column);
                    if (!cellValue || !cellValue.toString().toLowerCase().includes(filterValue.toLowerCase())) {
                        return false;
                    }
                }

                return true;
            });

            // Force reactivity by creating a new array reference
            this.filteredRows = [...filtered];

            this.applySorting();
            this.updateSelectAllState(); // Update selection state when filters change
        },

        startColumnResize(event, columnId) {
            this.isResizing = true;
            this.resizingColumnId = columnId;
            this.startX = event.clientX;

            // Get the current width of the column
            const th = event.target.closest('th');
            this.resizingTh = th;
            this.startWidth = th.offsetWidth;

            // Add global mouse event listeners
            document.addEventListener('mousemove', this.handleColumnResize.bind(this));
            document.addEventListener('mouseup', this.stopColumnResize.bind(this));

            // Prevent text selection during resize
            document.body.style.userSelect = 'none';
            document.body.style.cursor = 'col-resize';
        },

        handleColumnResize(event) {
            if (!this.isResizing || !this.resizingTh) return;

            const deltaX = event.clientX - this.startX;
            const newWidth = Math.max(80, this.startWidth + deltaX); // Minimum width of 80px

            // Update the stored TH element width
            this.resizingTh.style.width = newWidth + 'px';
            this.resizingTh.style.minWidth = newWidth + 'px';
        },

        stopColumnResize() {
            if (!this.isResizing) return;

            this.isResizing = false;
            this.resizingColumnId = null;
            this.resizingTh = null;

            // Remove event listeners
            document.removeEventListener('mousemove', this.handleColumnResize.bind(this));
            document.removeEventListener('mouseup', this.stopColumnResize.bind(this));

            // Restore cursor and text selection
            document.body.style.userSelect = '';
            document.body.style.cursor = '';
        },

init() {
            // HTMX event listener for delete row response (keeping for delete functionality)

            // HTMX event listener for delete row response
            document.addEventListener('htmx:afterRequest', (event) => {
                if (event.detail.xhr && event.detail.xhr.responseURL &&
                    event.detail.xhr.responseURL.includes('delete')) {
                    try {
                        const response = JSON.parse(event.detail.xhr.response);
                        if (response.success) {
                            // Row was deleted successfully, HTMX already removed it from DOM
                            // No additional action needed for data arrays since HTMX handles DOM updates
                        }
                    } catch (e) {
                        // HTMX delete responses might not be JSON, ignore parsing errors
                    }
                }
            });
        }
    }
}

// CSRF protection enabled





// Add column modal functions
function showAddColumnModal() {
    document.getElementById('add-column-modal').classList.remove('hidden');
    document.getElementById('column-name').focus();
}

function hideAddColumnModal() {
    document.getElementById('add-column-modal').classList.add('hidden');
    document.getElementById('column-name').value = '';
    document.getElementById('column-type').selectedIndex = 0;
}

function confirmAddColumn() {
    const name = document.getElementById('column-name').value.trim();
    const type = document.getElementById('column-type').value;

    if (!name) {
        alert('Please enter a column name.');
        document.getElementById('column-name').focus();
        return;
    }

    const listId = {{ list.pk }};
    fetch(`/lists/${listId}/columns/create/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-CSRFToken': csrftoken,
        },
        body: `name=${encodeURIComponent(name)}&column_type=${type}&required=false`
    })
    .then(response => {
        if (response.ok) {
            location.reload();
        } else {
            alert('Error adding column');
        }
    })
    .catch(error => {
        alert('Error adding column');
    });

    hideAddColumnModal();
}

// Delete list modal functions
function showDeleteListModal() {
    document.getElementById('delete-list-modal').classList.remove('hidden');
    document.getElementById('delete-confirmation-input').focus();
}

function hideDeleteListModal() {
    document.getElementById('delete-list-modal').classList.add('hidden');
    document.getElementById('delete-confirmation-input').value = '';
}

function confirmDeleteList() {
    const input = document.getElementById('delete-confirmation-input');
    const confirmation = input.value.trim();
    const listName = '{{ list.name }}';

    if (confirmation !== listName) {
        alert('Please type the exact list name to confirm deletion.');
        input.focus();
        return;
    }

    const listId = {{ list.pk }};
    fetch(`/lists/${listId}/delete/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-CSRFToken': csrftoken,
        },
        body: `confirmation=${encodeURIComponent(confirmation)}`
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = '{% url "list_list" %}';
        } else {
            alert(data.error || 'Error deleting list');
        }
    })
    .catch(error => {
        alert('Error deleting list');
    });
}
</script>
{% endblock %}